{% extends 'base.html' %}
{% block content %}



<!-- stored d3 files in base.html -->


<div class="container-fluid">
	<div class="row-fluid">
		 <div class="col-md-3" id="card-summary">
		 	<strong>Card Info:</strong>

			<!-- for loop in jinjia! -->
			{% for card in query_results %}
				<br>
				<br>
				Card name: {{card.card_name}}
				<br>
				Card debt: {{card.card_debt }}	
				<br>
				Card apr: {{card.card_apr}}
				<br>
				Card time to pay off: {{card.card_date}}
				<br>
			{% endfor %}
			<br>
			<br>
		 </div>
  		<div class="col-md-9" id="main">
  			<div class="col-xs-12 col-md-12 col-lg-12" id="visualization">
				Visualization:
				<div id="viz1">
					<script type="text/javascript">
						//Width and height
						var w = 500;
						var h = 300;
						var padding = 30;
						
						//Dynamic, random dataset
						var dataset = [];					//Initialize empty array
						var numDataPoints = 50;				//Number of dummy data points to create
						var xRange = Math.random() * 1000;	//Max range of new x values
						var yRange = Math.random() * 1000;	//Max range of new y values
						for (var i = 0; i < numDataPoints; i++) {					//Loop numDataPoints times
							var newNumber1 = Math.floor(Math.random() * xRange);	//New random integer
							var newNumber2 = Math.floor(Math.random() * yRange);	//New random integer
							dataset.push([newNumber1, newNumber2]);					//Add new number to array
						}
						//Create scale functions
						var xScale = d3.scale.linear()
											 .domain([0, d3.max(dataset, function(d) { return d[0]; })])
											 .range([padding, w - padding * 2]);
						var yScale = d3.scale.linear()
											 .domain([0, d3.max(dataset, function(d) { return d[1]; })])
											 .range([h - padding, padding]);
						var rScale = d3.scale.linear()
											 .domain([0, d3.max(dataset, function(d) { return d[1]; })])
											 .range([2, 5]);
						var formatAsPercentage = d3.format(".1%");
						//Define X axis
						var xAxis = d3.svg.axis()
										  .scale(xScale)
										  .orient("bottom")
										  .ticks(5)
										  .tickFormat(formatAsPercentage);
						//Define Y axis
						var yAxis = d3.svg.axis()
										  .scale(yScale)
										  .orient("left")
										  .ticks(5)
										  .tickFormat(formatAsPercentage);
						//Create SVG element
						var svg = d3.select("#viz1")
									.append("svg")
									.attr("width", w)
									.attr("height", h);
						//Create circles
						svg.selectAll("circle")
						   .data(dataset)
						   .enter()
						   .append("circle")
						   .attr("cx", function(d) {
						   		return xScale(d[0]);
						   })
						   .attr("cy", function(d) {
						   		return yScale(d[1]);
						   })
						   .attr("r", function(d) {
						   		return rScale(d[1]);
						   });
			
						
						//Create X axis
						svg.append("g")
							.attr("class", "axis")
							.attr("transform", "translate(0," + (h - padding) + ")")
							.call(xAxis);
						
						//Create Y axis
						svg.append("g")
							.attr("class", "axis")
							.attr("transform", "translate(" + padding + ",0)")
							.call(yAxis);
					</script>
				</div>
				

				<div id="viz3">
					Viz 3: 
					<script>

					var format = d3.time.format("%Y-%m-%d");


					var margin = {top: 20, right: 30, bottom: 30, left: 40},
					    width = 960 - margin.left - margin.right,
					    height = 500 - margin.top - margin.bottom;

					var x = d3.time.scale()
					    .range([0, width]);

					var y = d3.scale.linear()
					    .range([height, 0]);

					var z = d3.scale.category20c();

					var xAxis = d3.svg.axis()
					    .scale(x)
					    .orient("bottom");
					    // .ticks(d3.time.months);

					var yAxis = d3.svg.axis()
					    .scale(y)
					    .orient("left");

// All of the 2nd-dimensional arrays must be the same length.

					var stack = d3.layout.stack()
					    .offset("zero")
					    .values(function(d) { return d.values; })
					    .x(function(d) { return d.date; })
					    .y(function(d) { return d.amount; });


// TODO: 
// Go through data and make sure that Sugg has as many points as Min does. Add (date,0) for points
 // if you have missing data or inconsistent x-coordinates per series, you must resample and interpolate your data before computing the stacked layout.


					var nest = d3.nest()
					    .key(function(d) { return d.types; });
					    		// .key(function(d) { return d.types; })
					    		// .key(function(d) { return d.date; });
					    		// .entries(amount);


// var nest = d3.nest()
//     .key(function(d) { return d.year; })
//     .key(function(d) { return d.variety; })
//     .entries(yields);

					var area = d3.svg.area()
					    .interpolate("cardinal")
					    .x(function(d) { return x(d.date); })
					    .y0(function(d) { return y(d.y0); })
					    .y1(function(d) { return y(d.y0 + d.y); });

					var svg = d3.select("#viz3").append("svg")
					    .attr("width", width + margin.left + margin.right)
					    .attr("height", height + margin.top + margin.bottom)
					  .append("g")
					    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

					d3.json("../static/d3-data.json", function(data) {
					  data.forEach(function(d) {
					    d.date = format.parse(d.date)
					    // format(new Date(d.date))
					    d.amount = +d.amount;
					  });

					// function getDate(d) {
					//     return new Date(d.jsonDate);
					// }

					// // get max and min dates - this assumes data is sorted
					// var minDate = getDate(data[0]),
					//     maxDate = getDate(data[data.length-1]);

					// var x = d3.time.scale().domain([minDate, maxDate]).range([0, w]);

					  var layers = stack(nest.entries(data));

					  x.domain(d3.extent(data, function(d) { return d.date; }));
					  y.domain([0, d3.max(data, function(d) { return d.y0 + d.y; })]);

					  svg.selectAll(".layer")
					      .data(layers)
					    .enter().append("path")
					      .attr("class", "layer")
					      .attr("d", function(d) { return area(d.values); })
					      .style("fill", function(d, i) { return z(i); });

					  svg.append("g")
					      .attr("class", "x axis")
					      .attr("transform", "translate(0," + height + ")")
					      .call(xAxis);

					  svg.append("g")
					      .attr("class", "y axis")
					      .call(yAxis);
					});

					</script>
				</div>


			</div>

	 
			<div class="col-xs-6 col-md-6 col-lg-6">
				<div id="sugg_plan">
					<br>
					<br>
					Suggested
						<br>
						<br>
						<!--  convert to strings -->
						<strong>Total Suggested Debt Decreasing (Debt, Int, Payment):</strong>
						{{all_totals[1].to_html(classes="table table-striped") | safe}}
						
						<br>
						<br>
				</div>
			</div>

			<div class="col-xs-6 col-md-6 col-lg-6">
				<div id="min_plan">
						<br>
						<br>
						Minimum
						<br>
						<br>
						<strong>Total Minimum Debt (Debt, Int, Payment):</strong>
						{{all_totals[0].to_html(classes="table table-striped") | safe}}
						<br>	
						<br>
						<br>
				</div>
			</div>
		</div>
	</div>
</div>

<!-- 
#TODO
Figure out a way to not have graph go up to 6000. its adding up all sum totals. but only want it to add up sugg and min separately.
also have floating text above points for viewer to hover over.  -->


<div id="action">
	Take action div.
	<!--  add in a note here that if a card doesn't have 0apr, suggest to switch to a 0 apr
	ONLY if they can pay it off within that date... -->
</div>

<!-- Use this! http://getbootstrap.com/examples/dashboard/ -->



{% endblock %}


